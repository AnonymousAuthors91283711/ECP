[write_program]
The problem relates to characterizing integer pairs \((m, n)\) such that every subset \(A \subseteq \mathbb{Z}\) containing both \(m, n\) and closed under the operation \(x^2 + kxy + y^2\) for all \(k \in \mathbb{Z}\) must be the entire integer set. We enumerate pairs \((m,n)\) with small integer values and test whether the set generated by closure is all integers or smaller, printing the pairs corresponding to the universal closure property.

```python
# Enumerate integer pairs (m,n) with |m|,|n| ≤ 5
# For each, check if closure under x^2 + kxy + y^2 for all k generates all integers
# We approximate "generates all integers" by checking if closure contains at least all integers in [-20,20]

def closure_contains_all(m, n):
    # Start with A={m,n}
    A = {m, n}
    prev_len = -1
    # We consider k in [-2,2] for computational feasibility (since all k ∈ ℤ is infinite)
    ks = range(-2, 3)
    # We'll iterate closure up to 5 times or until no new elements
    for _ in range(5):
        new_elements = set()
        for x in A:
            for y in A:
                for k in ks:
                    val = x*x + k*x*y + y*y
                    if val not in A:
                        new_elements.add(val)
        A_new = A | new_elements
        if len(A_new) == prev_len:
            break
        prev_len = len(A_new)
        A = A_new
    # Check if A contains all integers in [-20,20]
    for v in range(-20, 21):
        if v not in A:
            return False
    return True

print("Enumerating pairs (m,n) with |m|, |n| ≤ 5 that generate full closure:")

for m in range(-5, 6):
    for n in range(-5, 6):
        # Skip if m,n same? No, check all
        if closure_contains_all(m,n):
            print(f"Pair generating full closure: ({m}, {n})")
```
