[write_program]
The problem involves analyzing the sequence defined recursively by build_row where each new row is constructed from the previous using the rule: interior elements are sums of neighboring elements plus 1, with 1's at both ends. The question asks for the last digit of the sum of the 2023rd row's elements modulo 10.

We will write a Python program to compute the sums of the first several rows modulo 10, looking for a pattern or cycle to conjecture the answer for row 2023 efficiently.

```python
# Compute and print the last digit of sum of rows generated by given recurrence
# row 0 = [1]
# row 1 = [1, 1]
# row n+2 = [1] + [prev[i] + prev[i+1] + 1 for i in range(len(prev)-1)] + [1]

def build_row(n):
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    prev = build_row(n - 1)
    interior = [prev[i] + prev[i + 1] + 1 for i in range(len(prev) - 1)]
    return [1] + interior + [1]

def sum_mod_10(n):
    # To speed up, only track sums mod 10 without constructing full rows
    # S_0 = sum(build_row(0)) = 1
    # S_1 = sum(build_row(1)) = 2
    # Then from the relation, find S_n+2 in terms of S_n+1 and S_n.
    # However, let's generate a few sums directly to search for a pattern.
    
    sums = []
    rows = [[1], [1, 1]]
    sums.append(sum(rows[0]) % 10)
    print(f"n=0 sum mod 10 = {sums[-1]}")
    sums.append(sum(rows[1]) % 10)
    print(f"n=1 sum mod 10 = {sums[-1]}")
    
    max_n = 50  # Check first 50 sums for a pattern
    for i in range(2, max_n):
        prev = rows[-1]
        interior = [prev[j] + prev[j+1] + 1 for j in range(len(prev)-1)]
        row = [1] + interior + [1]
        rows.append(row)
        s = sum(row) % 10
        sums.append(s)
        print(f"n={i} sum mod 10 = {s}")
        
    return sums

sums = sum_mod_10(2023)

# Try to find any cycle in sums to conjecture sum_mod_10(2023)
def find_cycle(seq):
    max_cycle_length = 20
    for length in range(1, max_cycle_length+1):
        if all(seq[i] == seq[i + length] for i in range(len(seq) - length)):
            return length
    return None

cycle_len = find_cycle(sums)
print("Cycle length:", cycle_len)
if cycle_len:
    pos = 2023 % cycle_len
    print(f"Sum mod 10 for n=2023 (by cycle) = {sums[pos]}")
else:
    print("No cycle found, answer unknown")
```
