[write_program]
The problem describes a sequence \( p(n) \) on \( n=0,1,\ldots,10 \) with boundary values \( p(0)=0 \), \( p(10)=1 \), and a recurrence involving values at neighbors, weighted by \( \frac{n}{10} \) and \(1 - \frac{n}{10}\). The relation is:

\[
p_n = \frac{n}{10} p_{n-1} + \left(1 - \frac{n}{10}\right) p_{n+1}, \quad n=1,\ldots,9.
\]

We can rewrite it as a linear system for \( p_1,\ldots,p_9 \), with known \( p_0=0, p_{10}=1 \).

Goal: enumerate all \( p_1 \) candidates generated by numerically solving the system, to conjecture the exact rational solution for \( p_1 \).

Approach:
- Set up and solve the 9x9 linear system for \( p_1,\ldots,p_9 \) given \( p_0=0, p_{10}=1 \).
- Print each \( p_n \) as an exact rational.
- Output \( p_1 \) in exact form to conjecture the answer.

```python
from fractions import Fraction

def solve_system():
    # Numbering p_0..p_10 with p_0=0, p_10=1 fixed
    # Unknowns: p_1 ... p_9
    # For each n=1..9:
    # p_n = (n/10)*p_{n-1} + (1 - n/10)*p_{n+1}
    #
    # Rewrite:
    # p_n - (n/10)*p_{n-1} - (1 - n/10)*p_{n+1} = 0
    #
    # For n=1..9, p_0=0 and p_10=1 known, set up matrix A and vector b:
    # For n=1: p_1 - (1/10)*p_0 - (9/10)*p_2 = 0 => p_1 - 0 - 0.9 p_2 = 0
    # For n=9: p_9 - (9/10)*p_8 - (1/10)*p_10 = 0 => p_9 - 0.9 p_8 - 0.1*1=0 => p_9 -0.9 p_8=0.1
    #
    # In general:
    # Coefficients for p_{n-1}, p_n, p_{n+1} with RHS zero except at boundary terms.

    size = 9
    A = [[Fraction(0) for _ in range(size)] for __ in range(size)]
    b = [Fraction(0) for _ in range(size)]

    for i in range(size):
        n = i + 1
        # p_n coefficient
        A[i][i] = Fraction(1)
        # p_{n-1} coefficient (if n>1)
        if n > 1:
            A[i][i-1] = Fraction(-n,10)
        else:
            # p_0 = 0, term moves to RHS as - (n/10)*p_0=0
            pass
        # p_{n+1} coefficient (if n<9)
        if n < 9:
            A[i][i+1] = Fraction(-(10 - n),10)
        else:
            # p_{10} = 1 known, move to RHS
            b[i] += Fraction(10 - n,10)*1

    # Solve A x = b with fractions by Gaussian elimination
    x = gaussian_elimination(A,b)
    # p_0=0 and p_10=1 given
    p = [Fraction(0)] + x + [Fraction(1)]

    for idx,val in enumerate(p):
        print(f"p_{idx} = {val}")

    print(f"Answer candidate p_1 = {p[1]}")

def gaussian_elimination(A,b):
    n = len(b)
    A = [row[:] for row in A]
    b = b[:]

    for i in range(n):
        # Partial pivoting for stability (not strictly needed here)
        max_row = max(range(i,n), key=lambda r: abs(A[r][i]))
        if i != max_row:
            A[i], A[max_row] = A[max_row], A[i]
            b[i], b[max_row] = b[max_row], b[i]
        # Normalize pivot row
        pivot = A[i][i]
        if pivot == 0:
            raise ValueError("Singular matrix")
        for j in range(i,n):
            A[i][j] /= pivot
        b[i] /= pivot
        # Eliminate below
        for r in range(i+1,n):
            factor = A[r][i]
            for c in range(i,n):
                A[r][c] -= factor * A[i][c]
            b[r] -= factor * b[i]

    # Back substitution
    x = [Fraction(0)]*n
    for i in reversed(range(n)):
        val = b[i]
        for j in range(i+1,n):
            val -= A[i][j]*x[j]
        x[i] = val
    return x

if __name__ == "__main__":
    solve_system()
```
